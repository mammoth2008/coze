// Code generated by cozeloop. DO NOT EDIT.
package localstream

import (
	"context"
	"fmt"
	"io"

	"github.com/cloudwego/kitex/pkg/streaming"
)

type InMemStream[R any] struct {
	ctx      context.Context
	msgCh    chan R
	errCh    chan error
	sendDone chan struct{}
	header   streaming.Header
	trailer  streaming.Trailer
}

func NewInMemStream[R any](ctx context.Context, ch chan R, errCh chan error) *InMemStream[R] {
	return &InMemStream[R]{
		ctx:      ctx,
		msgCh:    ch,
		errCh:    errCh,
		sendDone: make(chan struct{}),
	}
}

func (s *InMemStream[R]) Send(ctx context.Context, res R) error {
	select {
	case <-ctx.Done():
		return ctx.Err()
	case err := <-s.errCh:
		return err
	case <-s.sendDone:
		return fmt.Errorf("no send allowed when stream closed")
	default:
	}

	s.msgCh <- res
	return nil
}

func (s *InMemStream[R]) Recv(ctx context.Context) (r R, _ error) {
	select {
	case <-ctx.Done():
		return r, ctx.Err()
	case err := <-s.errCh:
		if err == nil {
			err = io.EOF
		}
		return r, err
	case msg, ok := <-s.msgCh:
		if !ok {
			return r, io.EOF
		}
		return msg, nil
	}
}

func (s *InMemStream[R]) SendMsg(ctx context.Context, m any) error {
	if r, ok := m.(R); ok {
		return s.Send(ctx, r)
	}
	return fmt.Errorf("invalid message type: %T", m)
}

func (s *InMemStream[R]) RecvMsg(ctx context.Context, m any) error {
	return fmt.Errorf("unsupported")
}

func (s *InMemStream[R]) SetHeader(hd streaming.Header) error {
	if s.header == nil {
		s.header = make(streaming.Header, len(hd))
	}
	for k, v := range hd {
		s.header[k] = v
	}
	return nil
}

func (s *InMemStream[R]) SendHeader(hd streaming.Header) error {
	// do nothing
	return nil
}

func (s *InMemStream[R]) SetTrailer(hd streaming.Trailer) error {
	if s.trailer == nil {
		s.trailer = make(streaming.Trailer)
	}
	for k, v := range hd {
		s.trailer[k] = v
	}
	return nil
}

func (s *InMemStream[R]) Header() (streaming.Header, error) {
	if s.header == nil {
		return nil, nil
	}
	hd := make(streaming.Header, len(s.header))
	for k, v := range s.header {
		hd[k] = v
	}
	return hd, nil
}

func (s *InMemStream[R]) Trailer() (streaming.Trailer, error) {
	if s.trailer == nil {
		return nil, nil
	}
	hd := make(streaming.Trailer, len(s.trailer))
	for k, v := range s.trailer {
		hd[k] = v
	}
	return hd, nil
}

func (s *InMemStream[R]) CloseSend(ctx context.Context) error {
	select {
	case <-s.sendDone: // already closed
		return nil
	default:
		close(s.sendDone)
		close(s.msgCh)
		return nil
	}
}

func (s *InMemStream[R]) Context() context.Context {
	return s.ctx
}
