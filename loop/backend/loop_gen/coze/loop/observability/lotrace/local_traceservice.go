// Code generated by cozeloop. DO NOT EDIT.
package lotrace // import github.com/coze-dev/coze-loop/backend/lotrace

import (
	"context"

	"github.com/cloudwego/kitex/client/callopt"
	"github.com/cloudwego/kitex/pkg/endpoint"
	"github.com/cloudwego/kitex/pkg/rpcinfo"
	"github.com/coze-dev/coze-loop/backend/kitex_gen/coze/loop/observability/trace"
)

type LocalTraceService struct {
	impl trace.TraceService // the service implementation
	mds  endpoint.Middleware
}

func NewLocalTraceService(impl trace.TraceService, mds ...endpoint.Middleware) *LocalTraceService {
	return &LocalTraceService{
		impl: impl,
		mds:  endpoint.Chain(mds...),
	}
}

func (l *LocalTraceService) ListSpans(ctx context.Context, req *trace.ListSpansRequest, callOptions ...callopt.Option) (*trace.ListSpansResponse, error) {
	chain := l.mds(func(ctx context.Context, in, out interface{}) error {
		arg := in.(*trace.TraceServiceListSpansArgs)
		result := out.(*trace.TraceServiceListSpansResult)
		resp, err := l.impl.ListSpans(ctx, arg.Req)
		if err != nil {
			return err
		}
		result.SetSuccess(resp)
		return nil
	})

	arg := &trace.TraceServiceListSpansArgs{Req: req}
	result := &trace.TraceServiceListSpansResult{}
	ctx = l.injectRPCInfo(ctx, "ListSpans")
	if err := chain(ctx, arg, result); err != nil {
		return nil, err
	}
	return result.GetSuccess(), nil
}

func (l *LocalTraceService) GetTrace(ctx context.Context, req *trace.GetTraceRequest, callOptions ...callopt.Option) (*trace.GetTraceResponse, error) {
	chain := l.mds(func(ctx context.Context, in, out interface{}) error {
		arg := in.(*trace.TraceServiceGetTraceArgs)
		result := out.(*trace.TraceServiceGetTraceResult)
		resp, err := l.impl.GetTrace(ctx, arg.Req)
		if err != nil {
			return err
		}
		result.SetSuccess(resp)
		return nil
	})

	arg := &trace.TraceServiceGetTraceArgs{Req: req}
	result := &trace.TraceServiceGetTraceResult{}
	ctx = l.injectRPCInfo(ctx, "GetTrace")
	if err := chain(ctx, arg, result); err != nil {
		return nil, err
	}
	return result.GetSuccess(), nil
}

func (l *LocalTraceService) BatchGetTracesAdvanceInfo(ctx context.Context, req *trace.BatchGetTracesAdvanceInfoRequest, callOptions ...callopt.Option) (*trace.BatchGetTracesAdvanceInfoResponse, error) {
	chain := l.mds(func(ctx context.Context, in, out interface{}) error {
		arg := in.(*trace.TraceServiceBatchGetTracesAdvanceInfoArgs)
		result := out.(*trace.TraceServiceBatchGetTracesAdvanceInfoResult)
		resp, err := l.impl.BatchGetTracesAdvanceInfo(ctx, arg.Req)
		if err != nil {
			return err
		}
		result.SetSuccess(resp)
		return nil
	})

	arg := &trace.TraceServiceBatchGetTracesAdvanceInfoArgs{Req: req}
	result := &trace.TraceServiceBatchGetTracesAdvanceInfoResult{}
	ctx = l.injectRPCInfo(ctx, "BatchGetTracesAdvanceInfo")
	if err := chain(ctx, arg, result); err != nil {
		return nil, err
	}
	return result.GetSuccess(), nil
}

func (l *LocalTraceService) IngestTraces(ctx context.Context, req *trace.IngestTracesRequest, callOptions ...callopt.Option) (*trace.IngestTracesResponse, error) {
	chain := l.mds(func(ctx context.Context, in, out interface{}) error {
		arg := in.(*trace.TraceServiceIngestTracesArgs)
		result := out.(*trace.TraceServiceIngestTracesResult)
		resp, err := l.impl.IngestTraces(ctx, arg.Req)
		if err != nil {
			return err
		}
		result.SetSuccess(resp)
		return nil
	})

	arg := &trace.TraceServiceIngestTracesArgs{Req: req}
	result := &trace.TraceServiceIngestTracesResult{}
	ctx = l.injectRPCInfo(ctx, "IngestTraces")
	if err := chain(ctx, arg, result); err != nil {
		return nil, err
	}
	return result.GetSuccess(), nil
}

func (l *LocalTraceService) IngestTracesInner(ctx context.Context, req *trace.IngestTracesRequest, callOptions ...callopt.Option) (*trace.IngestTracesResponse, error) {
	chain := l.mds(func(ctx context.Context, in, out interface{}) error {
		arg := in.(*trace.TraceServiceIngestTracesInnerArgs)
		result := out.(*trace.TraceServiceIngestTracesInnerResult)
		resp, err := l.impl.IngestTracesInner(ctx, arg.Req)
		if err != nil {
			return err
		}
		result.SetSuccess(resp)
		return nil
	})

	arg := &trace.TraceServiceIngestTracesInnerArgs{Req: req}
	result := &trace.TraceServiceIngestTracesInnerResult{}
	ctx = l.injectRPCInfo(ctx, "IngestTracesInner")
	if err := chain(ctx, arg, result); err != nil {
		return nil, err
	}
	return result.GetSuccess(), nil
}

func (l *LocalTraceService) GetTracesMetaInfo(ctx context.Context, req *trace.GetTracesMetaInfoRequest, callOptions ...callopt.Option) (*trace.GetTracesMetaInfoResponse, error) {
	chain := l.mds(func(ctx context.Context, in, out interface{}) error {
		arg := in.(*trace.TraceServiceGetTracesMetaInfoArgs)
		result := out.(*trace.TraceServiceGetTracesMetaInfoResult)
		resp, err := l.impl.GetTracesMetaInfo(ctx, arg.Req)
		if err != nil {
			return err
		}
		result.SetSuccess(resp)
		return nil
	})

	arg := &trace.TraceServiceGetTracesMetaInfoArgs{Req: req}
	result := &trace.TraceServiceGetTracesMetaInfoResult{}
	ctx = l.injectRPCInfo(ctx, "GetTracesMetaInfo")
	if err := chain(ctx, arg, result); err != nil {
		return nil, err
	}
	return result.GetSuccess(), nil
}

func (l *LocalTraceService) CreateView(ctx context.Context, req *trace.CreateViewRequest, callOptions ...callopt.Option) (*trace.CreateViewResponse, error) {
	chain := l.mds(func(ctx context.Context, in, out interface{}) error {
		arg := in.(*trace.TraceServiceCreateViewArgs)
		result := out.(*trace.TraceServiceCreateViewResult)
		resp, err := l.impl.CreateView(ctx, arg.Req)
		if err != nil {
			return err
		}
		result.SetSuccess(resp)
		return nil
	})

	arg := &trace.TraceServiceCreateViewArgs{Req: req}
	result := &trace.TraceServiceCreateViewResult{}
	ctx = l.injectRPCInfo(ctx, "CreateView")
	if err := chain(ctx, arg, result); err != nil {
		return nil, err
	}
	return result.GetSuccess(), nil
}

func (l *LocalTraceService) UpdateView(ctx context.Context, req *trace.UpdateViewRequest, callOptions ...callopt.Option) (*trace.UpdateViewResponse, error) {
	chain := l.mds(func(ctx context.Context, in, out interface{}) error {
		arg := in.(*trace.TraceServiceUpdateViewArgs)
		result := out.(*trace.TraceServiceUpdateViewResult)
		resp, err := l.impl.UpdateView(ctx, arg.Req)
		if err != nil {
			return err
		}
		result.SetSuccess(resp)
		return nil
	})

	arg := &trace.TraceServiceUpdateViewArgs{Req: req}
	result := &trace.TraceServiceUpdateViewResult{}
	ctx = l.injectRPCInfo(ctx, "UpdateView")
	if err := chain(ctx, arg, result); err != nil {
		return nil, err
	}
	return result.GetSuccess(), nil
}

func (l *LocalTraceService) DeleteView(ctx context.Context, req *trace.DeleteViewRequest, callOptions ...callopt.Option) (*trace.DeleteViewResponse, error) {
	chain := l.mds(func(ctx context.Context, in, out interface{}) error {
		arg := in.(*trace.TraceServiceDeleteViewArgs)
		result := out.(*trace.TraceServiceDeleteViewResult)
		resp, err := l.impl.DeleteView(ctx, arg.Req)
		if err != nil {
			return err
		}
		result.SetSuccess(resp)
		return nil
	})

	arg := &trace.TraceServiceDeleteViewArgs{Req: req}
	result := &trace.TraceServiceDeleteViewResult{}
	ctx = l.injectRPCInfo(ctx, "DeleteView")
	if err := chain(ctx, arg, result); err != nil {
		return nil, err
	}
	return result.GetSuccess(), nil
}

func (l *LocalTraceService) ListViews(ctx context.Context, req *trace.ListViewsRequest, callOptions ...callopt.Option) (*trace.ListViewsResponse, error) {
	chain := l.mds(func(ctx context.Context, in, out interface{}) error {
		arg := in.(*trace.TraceServiceListViewsArgs)
		result := out.(*trace.TraceServiceListViewsResult)
		resp, err := l.impl.ListViews(ctx, arg.Req)
		if err != nil {
			return err
		}
		result.SetSuccess(resp)
		return nil
	})

	arg := &trace.TraceServiceListViewsArgs{Req: req}
	result := &trace.TraceServiceListViewsResult{}
	ctx = l.injectRPCInfo(ctx, "ListViews")
	if err := chain(ctx, arg, result); err != nil {
		return nil, err
	}
	return result.GetSuccess(), nil
}

func (l *LocalTraceService) injectRPCInfo(ctx context.Context, method string) context.Context {
	rpcStats := rpcinfo.AsMutableRPCStats(rpcinfo.NewRPCStats())
	ri := rpcinfo.NewRPCInfo(
		rpcinfo.NewEndpointInfo("TraceService", method, nil, nil),
		rpcinfo.NewEndpointInfo("TraceService", method, nil, nil),
		rpcinfo.NewServerInvocation(),
		nil,
		rpcStats.ImmutableView(),
	)
	return rpcinfo.NewCtxWithRPCInfo(ctx, ri)
}
