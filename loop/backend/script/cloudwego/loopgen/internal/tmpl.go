// Copyright (c) 2025 coze-dev Authors
// SPDX-License-Identifier: Apache-2.0

package internal

import "text/template"

type Schema struct {
	Package            string      // localrpc package name
	ImportPath         string      // import path of localrpc package
	Imports            []string    // quoted import paths
	ServicePkg         string      // thrift service package name
	ServiceType        string      // thrift service type name
	ClientType         string      // localrpc client type name
	HasServerStreaming bool        // whether the service has server streaming
	Functions          []*Function // functions in client
}

type Function struct {
	Name            string
	Comments        string
	In              string
	Out             string
	StubArgs        string
	Void            bool
	ServerStreaming bool
	ArgType         string
	ResultType      string
	StreamRespIdent string // somepkg.SomeRep
	ReqFieldInArg   string // Request, Req
	ReqNameInArg    string // request, req
}

var rpcTmpl = template.Must(template.New("rpc").Parse(rpcGoTmpl))

const rpcGoTmpl = `// Code generated by cozeloop. DO NOT EDIT.
package {{.Package}}{{ if ne .ImportPath "" }} // import {{.ImportPath}}{{ end }}

import (
	{{- range .Imports}}
	{{.}}{{ end }}
)

type {{.ClientType}} struct {
	impl {{.ServicePkg}}.{{.ServiceType}} // the service implementation
	mds endpoint.Middleware
}

func New{{.ClientType}}(impl {{.ServicePkg}}.{{.ServiceType}}, mds ...endpoint.Middleware) *{{.ClientType}} {
	return &{{.ClientType}}{
		impl: impl,
		mds:  endpoint.Chain(mds...),
	}
}

{{ range .Functions }}{{ if ne .Comments "" }}// {{.Name}}
{{.Comments}}
{{ end -}}
{{ if .Void }}func (l *{{$.ClientType}}) {{.Name}}({{ .In }}) {{ .Out }} {
	return l.impl.{{.Name}}({{.StubArgs}})
}
{{ else if .ServerStreaming}}func (l *{{$.ClientType}}) {{.Name}}({{.In}}) ({{.Out}}) {
	ctx = l.injectRPCInfo(ctx, "{{.Name}}")
	errCh := make(chan error)
	msgCh := make(chan {{.StreamRespIdent}})
	ls := localstream.NewInMemStream(ctx, msgCh, errCh)

	go func() {
		defer func() {
			if r := recover(); r != nil {
				errCh <- fmt.Errorf("panic recovered: %v", r)
			}
		}()
		defer func() { _ = ls.CloseSend(ctx) }()

		if err := l.impl.{{.Name}}(ctx, {{.ReqNameInArg}}, ls); err != nil {
			errCh <- err
		}
	}()

	return ls, nil
}

{{ else }}func (l *{{$.ClientType}}) {{.Name}}({{ .In }}) ({{ .Out }}) {
	chain := l.mds(func(ctx context.Context, in, out interface{}) error {
		arg := in.(*{{.ArgType}})
		result := out.(*{{.ResultType}})
		resp, err := l.impl.{{.Name}}(ctx, arg.{{ .ReqFieldInArg }})
		if err != nil {
			return err
		}
		result.SetSuccess(resp)
		return nil
	})

	arg := &{{.ArgType}}{{"{"}}{{.ReqFieldInArg}}: {{.ReqNameInArg}}{{"}"}}
	result := &{{.ResultType}}{}
	ctx = l.injectRPCInfo(ctx, "{{.Name}}")
	if err := chain(ctx, arg, result); err != nil {
		return nil, err
	}
	return result.GetSuccess(), nil
}
{{ end }}
{{ end -}}


func (l *{{$.ClientType}}) injectRPCInfo(ctx context.Context, method string) context.Context {
	rpcStats := rpcinfo.AsMutableRPCStats(rpcinfo.NewRPCStats())
	ri := rpcinfo.NewRPCInfo(
		rpcinfo.NewEndpointInfo("{{$.ServiceType}}", method, nil, nil),
		rpcinfo.NewEndpointInfo("{{$.ServiceType}}", method, nil, nil),
		rpcinfo.NewServerInvocation(),
		nil,
		rpcStats.ImmutableView(),
	)
	return rpcinfo.NewCtxWithRPCInfo(ctx, ri)
}
`
