// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/coze-dev/coze-loop/backend/modules/data/infra/repo/dataset/mysql (interfaces: IVersionDAO)
//
// Generated by this command:
//
//	mockgen -destination=mocks/version_dao.go -package=mocks . IVersionDAO
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	db "github.com/coze-dev/coze-loop/backend/infra/db"
	mysql "github.com/coze-dev/coze-loop/backend/modules/data/infra/repo/dataset/mysql"
	model "github.com/coze-dev/coze-loop/backend/modules/data/infra/repo/dataset/mysql/gorm_gen/model"
	pagination "github.com/coze-dev/coze-loop/backend/modules/data/pkg/pagination"
	gomock "go.uber.org/mock/gomock"
)

// MockIVersionDAO is a mock of IVersionDAO interface.
type MockIVersionDAO struct {
	ctrl     *gomock.Controller
	recorder *MockIVersionDAOMockRecorder
	isgomock struct{}
}

// MockIVersionDAOMockRecorder is the mock recorder for MockIVersionDAO.
type MockIVersionDAOMockRecorder struct {
	mock *MockIVersionDAO
}

// NewMockIVersionDAO creates a new mock instance.
func NewMockIVersionDAO(ctrl *gomock.Controller) *MockIVersionDAO {
	mock := &MockIVersionDAO{ctrl: ctrl}
	mock.recorder = &MockIVersionDAOMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIVersionDAO) EXPECT() *MockIVersionDAOMockRecorder {
	return m.recorder
}

// CountVersions mocks base method.
func (m *MockIVersionDAO) CountVersions(ctx context.Context, params *mysql.ListDatasetVersionsParams, opt ...db.Option) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, params}
	for _, a := range opt {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CountVersions", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CountVersions indicates an expected call of CountVersions.
func (mr *MockIVersionDAOMockRecorder) CountVersions(ctx, params any, opt ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, params}, opt...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountVersions", reflect.TypeOf((*MockIVersionDAO)(nil).CountVersions), varargs...)
}

// CreateVersion mocks base method.
func (m *MockIVersionDAO) CreateVersion(ctx context.Context, version *model.DatasetVersion, opt ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, version}
	for _, a := range opt {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateVersion", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateVersion indicates an expected call of CreateVersion.
func (mr *MockIVersionDAOMockRecorder) CreateVersion(ctx, version any, opt ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, version}, opt...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateVersion", reflect.TypeOf((*MockIVersionDAO)(nil).CreateVersion), varargs...)
}

// GetVersion mocks base method.
func (m *MockIVersionDAO) GetVersion(ctx context.Context, spaceID, versionID int64, opt ...db.Option) (*model.DatasetVersion, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, spaceID, versionID}
	for _, a := range opt {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetVersion", varargs...)
	ret0, _ := ret[0].(*model.DatasetVersion)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetVersion indicates an expected call of GetVersion.
func (mr *MockIVersionDAOMockRecorder) GetVersion(ctx, spaceID, versionID any, opt ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, spaceID, versionID}, opt...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetVersion", reflect.TypeOf((*MockIVersionDAO)(nil).GetVersion), varargs...)
}

// ListVersions mocks base method.
func (m *MockIVersionDAO) ListVersions(ctx context.Context, params *mysql.ListDatasetVersionsParams, opt ...db.Option) ([]*model.DatasetVersion, *pagination.PageResult, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, params}
	for _, a := range opt {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListVersions", varargs...)
	ret0, _ := ret[0].([]*model.DatasetVersion)
	ret1, _ := ret[1].(*pagination.PageResult)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListVersions indicates an expected call of ListVersions.
func (mr *MockIVersionDAOMockRecorder) ListVersions(ctx, params any, opt ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, params}, opt...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListVersions", reflect.TypeOf((*MockIVersionDAO)(nil).ListVersions), varargs...)
}

// MGetVersions mocks base method.
func (m *MockIVersionDAO) MGetVersions(ctx context.Context, spaceID int64, ids []int64, opt ...db.Option) ([]*model.DatasetVersion, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, spaceID, ids}
	for _, a := range opt {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MGetVersions", varargs...)
	ret0, _ := ret[0].([]*model.DatasetVersion)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MGetVersions indicates an expected call of MGetVersions.
func (mr *MockIVersionDAOMockRecorder) MGetVersions(ctx, spaceID, ids any, opt ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, spaceID, ids}, opt...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MGetVersions", reflect.TypeOf((*MockIVersionDAO)(nil).MGetVersions), varargs...)
}

// PatchVersion mocks base method.
func (m *MockIVersionDAO) PatchVersion(ctx context.Context, patch, where *model.DatasetVersion, opt ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, patch, where}
	for _, a := range opt {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PatchVersion", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// PatchVersion indicates an expected call of PatchVersion.
func (mr *MockIVersionDAOMockRecorder) PatchVersion(ctx, patch, where any, opt ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, patch, where}, opt...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PatchVersion", reflect.TypeOf((*MockIVersionDAO)(nil).PatchVersion), varargs...)
}
