// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/coze-dev/coze-loop/backend/modules/evaluation/infra/repo/evaluator/mysql (interfaces: EvaluatorDAO)

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	db "github.com/coze-dev/coze-loop/backend/infra/db"
	mysql "github.com/coze-dev/coze-loop/backend/modules/evaluation/infra/repo/evaluator/mysql"
	model "github.com/coze-dev/coze-loop/backend/modules/evaluation/infra/repo/evaluator/mysql/gorm_gen/model"
	"go.uber.org/mock/gomock"
)

// MockEvaluatorDAO is a mock of EvaluatorDAO interface.
type MockEvaluatorDAO struct {
	ctrl     *gomock.Controller
	recorder *MockEvaluatorDAOMockRecorder
}

// MockEvaluatorDAOMockRecorder is the mock recorder for MockEvaluatorDAO.
type MockEvaluatorDAOMockRecorder struct {
	mock *MockEvaluatorDAO
}

// NewMockEvaluatorDAO creates a new mock instance.
func NewMockEvaluatorDAO(ctrl *gomock.Controller) *MockEvaluatorDAO {
	mock := &MockEvaluatorDAO{ctrl: ctrl}
	mock.recorder = &MockEvaluatorDAOMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEvaluatorDAO) EXPECT() *MockEvaluatorDAOMockRecorder {
	return m.recorder
}

// BatchDeleteEvaluator mocks base method.
func (m *MockEvaluatorDAO) BatchDeleteEvaluator(arg0 context.Context, arg1 []int64, arg2 string, arg3 ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchDeleteEvaluator", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// BatchDeleteEvaluator indicates an expected call of BatchDeleteEvaluator.
func (mr *MockEvaluatorDAOMockRecorder) BatchDeleteEvaluator(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchDeleteEvaluator", reflect.TypeOf((*MockEvaluatorDAO)(nil).BatchDeleteEvaluator), varargs...)
}

// BatchGetEvaluatorByID mocks base method.
func (m *MockEvaluatorDAO) BatchGetEvaluatorByID(arg0 context.Context, arg1 []int64, arg2 bool, arg3 ...db.Option) ([]*model.Evaluator, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchGetEvaluatorByID", varargs...)
	ret0, _ := ret[0].([]*model.Evaluator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchGetEvaluatorByID indicates an expected call of BatchGetEvaluatorByID.
func (mr *MockEvaluatorDAOMockRecorder) BatchGetEvaluatorByID(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchGetEvaluatorByID", reflect.TypeOf((*MockEvaluatorDAO)(nil).BatchGetEvaluatorByID), varargs...)
}

// CheckNameExist mocks base method.
func (m *MockEvaluatorDAO) CheckNameExist(arg0 context.Context, arg1, arg2 int64, arg3 string, arg4 ...db.Option) (bool, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CheckNameExist", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CheckNameExist indicates an expected call of CheckNameExist.
func (mr *MockEvaluatorDAOMockRecorder) CheckNameExist(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckNameExist", reflect.TypeOf((*MockEvaluatorDAO)(nil).CheckNameExist), varargs...)
}

// CreateEvaluator mocks base method.
func (m *MockEvaluatorDAO) CreateEvaluator(arg0 context.Context, arg1 *model.Evaluator, arg2 ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateEvaluator", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateEvaluator indicates an expected call of CreateEvaluator.
func (mr *MockEvaluatorDAOMockRecorder) CreateEvaluator(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateEvaluator", reflect.TypeOf((*MockEvaluatorDAO)(nil).CreateEvaluator), varargs...)
}

// GetEvaluatorByID mocks base method.
func (m *MockEvaluatorDAO) GetEvaluatorByID(arg0 context.Context, arg1 int64, arg2 bool, arg3 ...db.Option) (*model.Evaluator, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetEvaluatorByID", varargs...)
	ret0, _ := ret[0].(*model.Evaluator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetEvaluatorByID indicates an expected call of GetEvaluatorByID.
func (mr *MockEvaluatorDAOMockRecorder) GetEvaluatorByID(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEvaluatorByID", reflect.TypeOf((*MockEvaluatorDAO)(nil).GetEvaluatorByID), varargs...)
}

// ListEvaluator mocks base method.
func (m *MockEvaluatorDAO) ListEvaluator(arg0 context.Context, arg1 *mysql.ListEvaluatorRequest, arg2 ...db.Option) (*mysql.ListEvaluatorResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListEvaluator", varargs...)
	ret0, _ := ret[0].(*mysql.ListEvaluatorResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListEvaluator indicates an expected call of ListEvaluator.
func (mr *MockEvaluatorDAOMockRecorder) ListEvaluator(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListEvaluator", reflect.TypeOf((*MockEvaluatorDAO)(nil).ListEvaluator), varargs...)
}

// UpdateEvaluatorDraftSubmitted mocks base method.
func (m *MockEvaluatorDAO) UpdateEvaluatorDraftSubmitted(arg0 context.Context, arg1 int64, arg2 bool, arg3 string, arg4 ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateEvaluatorDraftSubmitted", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateEvaluatorDraftSubmitted indicates an expected call of UpdateEvaluatorDraftSubmitted.
func (mr *MockEvaluatorDAOMockRecorder) UpdateEvaluatorDraftSubmitted(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateEvaluatorDraftSubmitted", reflect.TypeOf((*MockEvaluatorDAO)(nil).UpdateEvaluatorDraftSubmitted), varargs...)
}

// UpdateEvaluatorLatestVersion mocks base method.
func (m *MockEvaluatorDAO) UpdateEvaluatorLatestVersion(arg0 context.Context, arg1 int64, arg2, arg3 string, arg4 ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateEvaluatorLatestVersion", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateEvaluatorLatestVersion indicates an expected call of UpdateEvaluatorLatestVersion.
func (mr *MockEvaluatorDAOMockRecorder) UpdateEvaluatorLatestVersion(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateEvaluatorLatestVersion", reflect.TypeOf((*MockEvaluatorDAO)(nil).UpdateEvaluatorLatestVersion), varargs...)
}

// UpdateEvaluatorMeta mocks base method.
func (m *MockEvaluatorDAO) UpdateEvaluatorMeta(arg0 context.Context, arg1 *model.Evaluator, arg2 ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateEvaluatorMeta", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateEvaluatorMeta indicates an expected call of UpdateEvaluatorMeta.
func (mr *MockEvaluatorDAOMockRecorder) UpdateEvaluatorMeta(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateEvaluatorMeta", reflect.TypeOf((*MockEvaluatorDAO)(nil).UpdateEvaluatorMeta), varargs...)
}
