// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/coze-dev/coze-loop/backend/modules/evaluation/infra/repo/experiment/mysql (interfaces: ExptAggrResultDAO)

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	db "github.com/coze-dev/coze-loop/backend/infra/db"
	model "github.com/coze-dev/coze-loop/backend/modules/evaluation/infra/repo/experiment/mysql/gorm_gen/model"
	gomock "go.uber.org/mock/gomock"
)

// MockExptAggrResultDAO is a mock of ExptAggrResultDAO interface.
type MockExptAggrResultDAO struct {
	ctrl     *gomock.Controller
	recorder *MockExptAggrResultDAOMockRecorder
}

// MockExptAggrResultDAOMockRecorder is the mock recorder for MockExptAggrResultDAO.
type MockExptAggrResultDAOMockRecorder struct {
	mock *MockExptAggrResultDAO
}

// NewMockExptAggrResultDAO creates a new mock instance.
func NewMockExptAggrResultDAO(ctrl *gomock.Controller) *MockExptAggrResultDAO {
	mock := &MockExptAggrResultDAO{ctrl: ctrl}
	mock.recorder = &MockExptAggrResultDAOMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockExptAggrResultDAO) EXPECT() *MockExptAggrResultDAOMockRecorder {
	return m.recorder
}

// BatchCreateExptAggrResult mocks base method.
func (m *MockExptAggrResultDAO) BatchCreateExptAggrResult(arg0 context.Context, arg1 []*model.ExptAggrResult, arg2 ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchCreateExptAggrResult", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// BatchCreateExptAggrResult indicates an expected call of BatchCreateExptAggrResult.
func (mr *MockExptAggrResultDAOMockRecorder) BatchCreateExptAggrResult(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchCreateExptAggrResult", reflect.TypeOf((*MockExptAggrResultDAO)(nil).BatchCreateExptAggrResult), varargs...)
}

// BatchGetExptAggrResultByExperimentIDs mocks base method.
func (m *MockExptAggrResultDAO) BatchGetExptAggrResultByExperimentIDs(arg0 context.Context, arg1 []int64, arg2 ...db.Option) ([]*model.ExptAggrResult, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchGetExptAggrResultByExperimentIDs", varargs...)
	ret0, _ := ret[0].([]*model.ExptAggrResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchGetExptAggrResultByExperimentIDs indicates an expected call of BatchGetExptAggrResultByExperimentIDs.
func (mr *MockExptAggrResultDAOMockRecorder) BatchGetExptAggrResultByExperimentIDs(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchGetExptAggrResultByExperimentIDs", reflect.TypeOf((*MockExptAggrResultDAO)(nil).BatchGetExptAggrResultByExperimentIDs), varargs...)
}

// CreateExptAggrResult mocks base method.
func (m *MockExptAggrResultDAO) CreateExptAggrResult(arg0 context.Context, arg1 *model.ExptAggrResult, arg2 ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateExptAggrResult", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateExptAggrResult indicates an expected call of CreateExptAggrResult.
func (mr *MockExptAggrResultDAOMockRecorder) CreateExptAggrResult(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateExptAggrResult", reflect.TypeOf((*MockExptAggrResultDAO)(nil).CreateExptAggrResult), varargs...)
}

// GetExptAggrResult mocks base method.
func (m *MockExptAggrResultDAO) GetExptAggrResult(arg0 context.Context, arg1 int64, arg2 int32, arg3 string, arg4 ...db.Option) (*model.ExptAggrResult, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetExptAggrResult", varargs...)
	ret0, _ := ret[0].(*model.ExptAggrResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetExptAggrResult indicates an expected call of GetExptAggrResult.
func (mr *MockExptAggrResultDAOMockRecorder) GetExptAggrResult(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetExptAggrResult", reflect.TypeOf((*MockExptAggrResultDAO)(nil).GetExptAggrResult), varargs...)
}

// GetExptAggrResultByExperimentID mocks base method.
func (m *MockExptAggrResultDAO) GetExptAggrResultByExperimentID(arg0 context.Context, arg1 int64, arg2 ...db.Option) ([]*model.ExptAggrResult, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetExptAggrResultByExperimentID", varargs...)
	ret0, _ := ret[0].([]*model.ExptAggrResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetExptAggrResultByExperimentID indicates an expected call of GetExptAggrResultByExperimentID.
func (mr *MockExptAggrResultDAOMockRecorder) GetExptAggrResultByExperimentID(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetExptAggrResultByExperimentID", reflect.TypeOf((*MockExptAggrResultDAO)(nil).GetExptAggrResultByExperimentID), varargs...)
}

// UpdateAndGetLatestVersion mocks base method.
func (m *MockExptAggrResultDAO) UpdateAndGetLatestVersion(arg0 context.Context, arg1 int64, arg2 int32, arg3 string, arg4 ...db.Option) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateAndGetLatestVersion", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateAndGetLatestVersion indicates an expected call of UpdateAndGetLatestVersion.
func (mr *MockExptAggrResultDAOMockRecorder) UpdateAndGetLatestVersion(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateAndGetLatestVersion", reflect.TypeOf((*MockExptAggrResultDAO)(nil).UpdateAndGetLatestVersion), varargs...)
}

// UpdateExptAggrResultByVersion mocks base method.
func (m *MockExptAggrResultDAO) UpdateExptAggrResultByVersion(arg0 context.Context, arg1 *model.ExptAggrResult, arg2 int64, arg3 ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateExptAggrResultByVersion", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateExptAggrResultByVersion indicates an expected call of UpdateExptAggrResultByVersion.
func (mr *MockExptAggrResultDAOMockRecorder) UpdateExptAggrResultByVersion(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateExptAggrResultByVersion", reflect.TypeOf((*MockExptAggrResultDAO)(nil).UpdateExptAggrResultByVersion), varargs...)
}
