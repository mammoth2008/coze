// Code generated by Kitex v0.13.1. DO NOT EDIT.

package auth

import (
	"bytes"
	"fmt"
	"reflect"
	"strings"

	"github.com/cloudwego/gopkg/protocol/thrift"
	kutils "github.com/cloudwego/kitex/pkg/utils"
)

// unused protection
var (
	_ = fmt.Formatter(nil)
	_ = (*bytes.Buffer)(nil)
	_ = (*strings.Builder)(nil)
	_ = reflect.Type(nil)
	_ = thrift.STOP
)

func (p *AuthUser) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_AuthUser[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *AuthUser) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.SsoUsername = _field
	return offset, nil
}

func (p *AuthUser) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.UserID = _field
	return offset, nil
}

func (p *AuthUser) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *AuthUser) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *AuthUser) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *AuthUser) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSsoUsername() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.SsoUsername)
	}
	return offset
}

func (p *AuthUser) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetUserID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.UserID)
	}
	return offset
}

func (p *AuthUser) field1Length() int {
	l := 0
	if p.IsSetSsoUsername() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.SsoUsername)
	}
	return l
}

func (p *AuthUser) field2Length() int {
	l := 0
	if p.IsSetUserID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.UserID)
	}
	return l
}

func (p *AuthUser) DeepCopy(s interface{}) error {
	src, ok := s.(*AuthUser)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.SsoUsername != nil {
		var tmp string
		if *src.SsoUsername != "" {
			tmp = kutils.StringDeepCopy(*src.SsoUsername)
		}
		p.SsoUsername = &tmp
	}

	if src.UserID != nil {
		var tmp string
		if *src.UserID != "" {
			tmp = kutils.StringDeepCopy(*src.UserID)
		}
		p.UserID = &tmp
	}

	return nil
}

func (p *AuthDepartment) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_AuthDepartment[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *AuthDepartment) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.DepartmentID = _field
	return offset, nil
}

func (p *AuthDepartment) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *AuthDepartment) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *AuthDepartment) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *AuthDepartment) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetDepartmentID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.DepartmentID)
	}
	return offset
}

func (p *AuthDepartment) field1Length() int {
	l := 0
	if p.IsSetDepartmentID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.DepartmentID)
	}
	return l
}

func (p *AuthDepartment) DeepCopy(s interface{}) error {
	src, ok := s.(*AuthDepartment)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.DepartmentID != nil {
		var tmp string
		if *src.DepartmentID != "" {
			tmp = kutils.StringDeepCopy(*src.DepartmentID)
		}
		p.DepartmentID = &tmp
	}

	return nil
}

func (p *AuthCozeIdentifier) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_AuthCozeIdentifier[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *AuthCozeIdentifier) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.IdentityTicket = _field
	return offset, nil
}

func (p *AuthCozeIdentifier) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *AuthCozeIdentifier) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *AuthCozeIdentifier) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *AuthCozeIdentifier) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetIdentityTicket() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.IdentityTicket)
	}
	return offset
}

func (p *AuthCozeIdentifier) field1Length() int {
	l := 0
	if p.IsSetIdentityTicket() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.IdentityTicket)
	}
	return l
}

func (p *AuthCozeIdentifier) DeepCopy(s interface{}) error {
	src, ok := s.(*AuthCozeIdentifier)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.IdentityTicket != nil {
		var tmp string
		if *src.IdentityTicket != "" {
			tmp = kutils.StringDeepCopy(*src.IdentityTicket)
		}
		p.IdentityTicket = &tmp
	}

	return nil
}

func (p *AuthPrincipal) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_AuthPrincipal[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *AuthPrincipal) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *AuthPrincipalType
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := AuthPrincipalType(v)
		_field = &tmp
	}
	p.AuthPrincipalType = _field
	return offset, nil
}

func (p *AuthPrincipal) FastReadField2(buf []byte) (int, error) {
	offset := 0
	_field := NewAuthUser()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.AuthUser = _field
	return offset, nil
}

func (p *AuthPrincipal) FastReadField3(buf []byte) (int, error) {
	offset := 0
	_field := NewAuthDepartment()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.AuthDepartment = _field
	return offset, nil
}

func (p *AuthPrincipal) FastReadField4(buf []byte) (int, error) {
	offset := 0
	_field := NewAuthCozeIdentifier()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.AuthCozeIdentifier = _field
	return offset, nil
}

func (p *AuthPrincipal) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *AuthPrincipal) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *AuthPrincipal) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *AuthPrincipal) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetAuthPrincipalType() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 1)
		offset += thrift.Binary.WriteI32(buf[offset:], int32(*p.AuthPrincipalType))
	}
	return offset
}

func (p *AuthPrincipal) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetAuthUser() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 2)
		offset += p.AuthUser.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *AuthPrincipal) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetAuthDepartment() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 3)
		offset += p.AuthDepartment.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *AuthPrincipal) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetAuthCozeIdentifier() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 4)
		offset += p.AuthCozeIdentifier.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *AuthPrincipal) field1Length() int {
	l := 0
	if p.IsSetAuthPrincipalType() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *AuthPrincipal) field2Length() int {
	l := 0
	if p.IsSetAuthUser() {
		l += thrift.Binary.FieldBeginLength()
		l += p.AuthUser.BLength()
	}
	return l
}

func (p *AuthPrincipal) field3Length() int {
	l := 0
	if p.IsSetAuthDepartment() {
		l += thrift.Binary.FieldBeginLength()
		l += p.AuthDepartment.BLength()
	}
	return l
}

func (p *AuthPrincipal) field4Length() int {
	l := 0
	if p.IsSetAuthCozeIdentifier() {
		l += thrift.Binary.FieldBeginLength()
		l += p.AuthCozeIdentifier.BLength()
	}
	return l
}

func (p *AuthPrincipal) DeepCopy(s interface{}) error {
	src, ok := s.(*AuthPrincipal)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.AuthPrincipalType != nil {
		tmp := *src.AuthPrincipalType
		p.AuthPrincipalType = &tmp
	}

	var _authUser *AuthUser
	if src.AuthUser != nil {
		_authUser = &AuthUser{}
		if err := _authUser.DeepCopy(src.AuthUser); err != nil {
			return err
		}
	}
	p.AuthUser = _authUser

	var _authDepartment *AuthDepartment
	if src.AuthDepartment != nil {
		_authDepartment = &AuthDepartment{}
		if err := _authDepartment.DeepCopy(src.AuthDepartment); err != nil {
			return err
		}
	}
	p.AuthDepartment = _authDepartment

	var _authCozeIdentifier *AuthCozeIdentifier
	if src.AuthCozeIdentifier != nil {
		_authCozeIdentifier = &AuthCozeIdentifier{}
		if err := _authCozeIdentifier.DeepCopy(src.AuthCozeIdentifier); err != nil {
			return err
		}
	}
	p.AuthCozeIdentifier = _authCozeIdentifier

	return nil
}

func (p *AuthEntity) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_AuthEntity[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *AuthEntity) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ID = _field
	return offset, nil
}

func (p *AuthEntity) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *AuthEntityType
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.EntityType = _field
	return offset, nil
}

func (p *AuthEntity) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.SpaceID = _field
	return offset, nil
}

func (p *AuthEntity) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.OwnerUserID = _field
	return offset, nil
}

func (p *AuthEntity) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *AuthEntity) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *AuthEntity) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *AuthEntity) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.ID)
	}
	return offset
}

func (p *AuthEntity) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEntityType() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.EntityType)
	}
	return offset
}

func (p *AuthEntity) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSpaceID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 3)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.SpaceID)
	}
	return offset
}

func (p *AuthEntity) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetOwnerUserID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 4)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.OwnerUserID)
	}
	return offset
}

func (p *AuthEntity) field1Length() int {
	l := 0
	if p.IsSetID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.ID)
	}
	return l
}

func (p *AuthEntity) field2Length() int {
	l := 0
	if p.IsSetEntityType() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.EntityType)
	}
	return l
}

func (p *AuthEntity) field3Length() int {
	l := 0
	if p.IsSetSpaceID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.SpaceID)
	}
	return l
}

func (p *AuthEntity) field4Length() int {
	l := 0
	if p.IsSetOwnerUserID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.OwnerUserID)
	}
	return l
}

func (p *AuthEntity) DeepCopy(s interface{}) error {
	src, ok := s.(*AuthEntity)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.ID != nil {
		var tmp string
		if *src.ID != "" {
			tmp = kutils.StringDeepCopy(*src.ID)
		}
		p.ID = &tmp
	}

	if src.EntityType != nil {
		tmp := *src.EntityType
		p.EntityType = &tmp
	}

	if src.SpaceID != nil {
		var tmp string
		if *src.SpaceID != "" {
			tmp = kutils.StringDeepCopy(*src.SpaceID)
		}
		p.SpaceID = &tmp
	}

	if src.OwnerUserID != nil {
		var tmp string
		if *src.OwnerUserID != "" {
			tmp = kutils.StringDeepCopy(*src.OwnerUserID)
		}
		p.OwnerUserID = &tmp
	}

	return nil
}

func (p *SubjectActionObjects) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_SubjectActionObjects[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *SubjectActionObjects) FastReadField1(buf []byte) (int, error) {
	offset := 0
	_field := NewAuthPrincipal()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Subject = _field
	return offset, nil
}

func (p *SubjectActionObjects) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Action = _field
	return offset, nil
}

func (p *SubjectActionObjects) FastReadField3(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*AuthEntity, 0, size)
	values := make([]AuthEntity, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.Objects = _field
	return offset, nil
}

func (p *SubjectActionObjects) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *SubjectActionObjects) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *SubjectActionObjects) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *SubjectActionObjects) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSubject() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 1)
		offset += p.Subject.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *SubjectActionObjects) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetAction() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Action)
	}
	return offset
}

func (p *SubjectActionObjects) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetObjects() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 3)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.Objects {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *SubjectActionObjects) field1Length() int {
	l := 0
	if p.IsSetSubject() {
		l += thrift.Binary.FieldBeginLength()
		l += p.Subject.BLength()
	}
	return l
}

func (p *SubjectActionObjects) field2Length() int {
	l := 0
	if p.IsSetAction() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Action)
	}
	return l
}

func (p *SubjectActionObjects) field3Length() int {
	l := 0
	if p.IsSetObjects() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.Objects {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *SubjectActionObjects) DeepCopy(s interface{}) error {
	src, ok := s.(*SubjectActionObjects)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	var _subject *AuthPrincipal
	if src.Subject != nil {
		_subject = &AuthPrincipal{}
		if err := _subject.DeepCopy(src.Subject); err != nil {
			return err
		}
	}
	p.Subject = _subject

	if src.Action != nil {
		var tmp string
		if *src.Action != "" {
			tmp = kutils.StringDeepCopy(*src.Action)
		}
		p.Action = &tmp
	}

	if src.Objects != nil {
		p.Objects = make([]*AuthEntity, 0, len(src.Objects))
		for _, elem := range src.Objects {
			var _elem *AuthEntity
			if elem != nil {
				_elem = &AuthEntity{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.Objects = append(p.Objects, _elem)
		}
	}

	return nil
}

func (p *SubjectActionObjectAuthRes) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_SubjectActionObjectAuthRes[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *SubjectActionObjectAuthRes) FastReadField1(buf []byte) (int, error) {
	offset := 0
	_field := NewSubjectActionObjects()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.SubjectActionObjects = _field
	return offset, nil
}

func (p *SubjectActionObjectAuthRes) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *bool
	if v, l, err := thrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.IsAllowed = _field
	return offset, nil
}

func (p *SubjectActionObjectAuthRes) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *SubjectActionObjectAuthRes) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField1(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *SubjectActionObjectAuthRes) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *SubjectActionObjectAuthRes) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSubjectActionObjects() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 1)
		offset += p.SubjectActionObjects.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *SubjectActionObjectAuthRes) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetIsAllowed() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.BOOL, 2)
		offset += thrift.Binary.WriteBool(buf[offset:], *p.IsAllowed)
	}
	return offset
}

func (p *SubjectActionObjectAuthRes) field1Length() int {
	l := 0
	if p.IsSetSubjectActionObjects() {
		l += thrift.Binary.FieldBeginLength()
		l += p.SubjectActionObjects.BLength()
	}
	return l
}

func (p *SubjectActionObjectAuthRes) field2Length() int {
	l := 0
	if p.IsSetIsAllowed() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.BoolLength()
	}
	return l
}

func (p *SubjectActionObjectAuthRes) DeepCopy(s interface{}) error {
	src, ok := s.(*SubjectActionObjectAuthRes)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	var _subjectActionObjects *SubjectActionObjects
	if src.SubjectActionObjects != nil {
		_subjectActionObjects = &SubjectActionObjects{}
		if err := _subjectActionObjects.DeepCopy(src.SubjectActionObjects); err != nil {
			return err
		}
	}
	p.SubjectActionObjects = _subjectActionObjects

	if src.IsAllowed != nil {
		tmp := *src.IsAllowed
		p.IsAllowed = &tmp
	}

	return nil
}
