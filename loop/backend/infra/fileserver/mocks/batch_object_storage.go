// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/coze-dev/coze-loop/backend/infra/fileserver (interfaces: BatchObjectStorage)
//
// Generated by this command:
//
//	mockgen -destination=mocks/batch_object_storage.go -package=mocks . BatchObjectStorage
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	io "io"
	http "net/http"
	reflect "reflect"

	fileserver "github.com/coze-dev/coze-loop/backend/infra/fileserver"
	gomock "go.uber.org/mock/gomock"
)

// MockBatchObjectStorage is a mock of BatchObjectStorage interface.
type MockBatchObjectStorage struct {
	ctrl     *gomock.Controller
	recorder *MockBatchObjectStorageMockRecorder
	isgomock struct{}
}

// MockBatchObjectStorageMockRecorder is the mock recorder for MockBatchObjectStorage.
type MockBatchObjectStorageMockRecorder struct {
	mock *MockBatchObjectStorage
}

// NewMockBatchObjectStorage creates a new mock instance.
func NewMockBatchObjectStorage(ctrl *gomock.Controller) *MockBatchObjectStorage {
	mock := &MockBatchObjectStorage{ctrl: ctrl}
	mock.recorder = &MockBatchObjectStorageMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBatchObjectStorage) EXPECT() *MockBatchObjectStorageMockRecorder {
	return m.recorder
}

// BatchDownload mocks base method.
func (m *MockBatchObjectStorage) BatchDownload(ctx context.Context, keys []string, writers []io.WriterAt, opts ...fileserver.DownloadOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, keys, writers}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchDownload", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// BatchDownload indicates an expected call of BatchDownload.
func (mr *MockBatchObjectStorageMockRecorder) BatchDownload(ctx, keys, writers any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, keys, writers}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchDownload", reflect.TypeOf((*MockBatchObjectStorage)(nil).BatchDownload), varargs...)
}

// BatchRead mocks base method.
func (m *MockBatchObjectStorage) BatchRead(ctx context.Context, keys []string, opts ...fileserver.DownloadOpt) ([]fileserver.Reader, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, keys}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchRead", varargs...)
	ret0, _ := ret[0].([]fileserver.Reader)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchRead indicates an expected call of BatchRead.
func (mr *MockBatchObjectStorageMockRecorder) BatchRead(ctx, keys any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, keys}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchRead", reflect.TypeOf((*MockBatchObjectStorage)(nil).BatchRead), varargs...)
}

// BatchSignDownloadReq mocks base method.
func (m *MockBatchObjectStorage) BatchSignDownloadReq(ctx context.Context, keys []string, opts ...fileserver.SignOpt) ([]string, []http.Header, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, keys}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchSignDownloadReq", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].([]http.Header)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// BatchSignDownloadReq indicates an expected call of BatchSignDownloadReq.
func (mr *MockBatchObjectStorageMockRecorder) BatchSignDownloadReq(ctx, keys any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, keys}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchSignDownloadReq", reflect.TypeOf((*MockBatchObjectStorage)(nil).BatchSignDownloadReq), varargs...)
}

// BatchSignUploadReq mocks base method.
func (m *MockBatchObjectStorage) BatchSignUploadReq(ctx context.Context, keys []string, opts ...fileserver.SignOpt) ([]string, []http.Header, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, keys}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchSignUploadReq", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].([]http.Header)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// BatchSignUploadReq indicates an expected call of BatchSignUploadReq.
func (mr *MockBatchObjectStorageMockRecorder) BatchSignUploadReq(ctx, keys any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, keys}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchSignUploadReq", reflect.TypeOf((*MockBatchObjectStorage)(nil).BatchSignUploadReq), varargs...)
}

// BatchUpload mocks base method.
func (m *MockBatchObjectStorage) BatchUpload(ctx context.Context, keys []string, readers []io.Reader, opts ...fileserver.UploadOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, keys, readers}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchUpload", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// BatchUpload indicates an expected call of BatchUpload.
func (mr *MockBatchObjectStorageMockRecorder) BatchUpload(ctx, keys, readers any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, keys, readers}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchUpload", reflect.TypeOf((*MockBatchObjectStorage)(nil).BatchUpload), varargs...)
}

// Download mocks base method.
func (m *MockBatchObjectStorage) Download(ctx context.Context, key string, w io.WriterAt, opts ...fileserver.DownloadOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key, w}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Download", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Download indicates an expected call of Download.
func (mr *MockBatchObjectStorageMockRecorder) Download(ctx, key, w any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key, w}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Download", reflect.TypeOf((*MockBatchObjectStorage)(nil).Download), varargs...)
}

// Read mocks base method.
func (m *MockBatchObjectStorage) Read(ctx context.Context, key string, opts ...fileserver.DownloadOpt) (fileserver.Reader, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Read", varargs...)
	ret0, _ := ret[0].(fileserver.Reader)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Read indicates an expected call of Read.
func (mr *MockBatchObjectStorageMockRecorder) Read(ctx, key any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Read", reflect.TypeOf((*MockBatchObjectStorage)(nil).Read), varargs...)
}

// Remove mocks base method.
func (m *MockBatchObjectStorage) Remove(ctx context.Context, key string, opts ...fileserver.RemoveOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Remove", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Remove indicates an expected call of Remove.
func (mr *MockBatchObjectStorageMockRecorder) Remove(ctx, key any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Remove", reflect.TypeOf((*MockBatchObjectStorage)(nil).Remove), varargs...)
}

// SignDownloadReq mocks base method.
func (m *MockBatchObjectStorage) SignDownloadReq(ctx context.Context, key string, opts ...fileserver.SignOpt) (string, http.Header, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SignDownloadReq", varargs...)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(http.Header)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// SignDownloadReq indicates an expected call of SignDownloadReq.
func (mr *MockBatchObjectStorageMockRecorder) SignDownloadReq(ctx, key any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SignDownloadReq", reflect.TypeOf((*MockBatchObjectStorage)(nil).SignDownloadReq), varargs...)
}

// SignUploadReq mocks base method.
func (m *MockBatchObjectStorage) SignUploadReq(ctx context.Context, key string, opts ...fileserver.SignOpt) (string, http.Header, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SignUploadReq", varargs...)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(http.Header)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// SignUploadReq indicates an expected call of SignUploadReq.
func (mr *MockBatchObjectStorageMockRecorder) SignUploadReq(ctx, key any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SignUploadReq", reflect.TypeOf((*MockBatchObjectStorage)(nil).SignUploadReq), varargs...)
}

// Stat mocks base method.
func (m *MockBatchObjectStorage) Stat(ctx context.Context, key string, opts ...fileserver.StatOpt) (*fileserver.ObjectInfo, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Stat", varargs...)
	ret0, _ := ret[0].(*fileserver.ObjectInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Stat indicates an expected call of Stat.
func (mr *MockBatchObjectStorageMockRecorder) Stat(ctx, key any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stat", reflect.TypeOf((*MockBatchObjectStorage)(nil).Stat), varargs...)
}

// Upload mocks base method.
func (m *MockBatchObjectStorage) Upload(ctx context.Context, key string, r io.Reader, opts ...fileserver.UploadOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key, r}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Upload", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Upload indicates an expected call of Upload.
func (mr *MockBatchObjectStorageMockRecorder) Upload(ctx, key, r any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key, r}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Upload", reflect.TypeOf((*MockBatchObjectStorage)(nil).Upload), varargs...)
}
